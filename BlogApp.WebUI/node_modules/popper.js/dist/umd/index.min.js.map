{"version":3,"file":"index.min.js","sources":["../../src/dom-utils/getWindow.js","../../src/dom-utils/getComputedStyle.js","../../src/dom-utils/getElementClientRect.js","../../src/dom-utils/getParentNode.js","../../src/dom-utils/listScrollParents.js","../../src/dom-utils/getScrollParent.js","../../src/dom-utils/getNodeScroll.js","../../src/dom-utils/getHTMLElementScroll.js","../../src/dom-utils/getWindowScroll.js","../../src/dom-utils/getOffsetParent.js","../../src/dom-utils/getCommonTotalScroll.js","../../src/utils/unwrapJqueryElement.js","../../src/utils/orderModifiers.js","../../src/utils/expandEventListeners.js","../../src/enums.js","../../src/utils/computeOffsets.js","../../src/utils/getBasePlacement.js","../../src/utils/format.js","../../src/utils/validateModifiers.js","../../src/modifiers/computeStyles.js","../../src/modifiers/applyStyles.js","../../src/index.js","../../src/utils/debounce.js"],"sourcesContent":["// @flow\nexport default function getWindow(node: Node) {\n  const ownerDocument = node.ownerDocument;\n  return ownerDocument ? ownerDocument.defaultView : window;\n}\n","// @flow\nimport getWindow from './getWindow';\n\nexport default function getComputedStyle(element: HTMLElement) {\n  return getWindow(element).getComputedStyle(element);\n}\n","// @flow\nimport getComputedStyle from './getComputedStyle';\n\n// Returns the width, height and offsets of the provided element\nexport default (element: HTMLElement) => {\n  // get the basic client rect, it doesn't include margins\n  const width = element.offsetWidth;\n  const height = element.offsetHeight;\n  const top = element.offsetTop;\n  const left = element.offsetLeft;\n\n  // get the element margins, we need them to properly align the popper\n  const styles = getComputedStyle(element);\n\n  const marginTop = parseFloat(styles.marginTop) || 0;\n  const marginRight = parseFloat(styles.marginRight) || 0;\n  const marginBottom = parseFloat(styles.marginBottom) || 0;\n  const marginLeft = parseFloat(styles.marginLeft) || 0;\n\n  return {\n    width: width + marginLeft + marginRight,\n    height: height + marginTop + marginBottom,\n    y: top - marginTop,\n    x: left - marginLeft,\n  };\n};\n","// @flow\nexport default (element: Node | ShadowRoot): Node => {\n  if (element.nodeName === 'HTML') {\n    // DocumentElement detectedF\n    return element;\n  }\n  return (\n    element.parentNode || // DOM Element detected\n    // $FlowFixMe: need a better way to handle this...\n    element.host || // ShadowRoot detected\n    document.ownerDocument || // Fallback to ownerDocument if available\n    document.documentElement // Or to documentElement if everything else fails\n  );\n};\n","// @flow\nimport getScrollParent from './getScrollParent';\nimport getParentNode from './getParentNode';\n\nexport default function listScrollParents(\n  element: Node,\n  list: Array<Node> = []\n): Array<Node> {\n  const scrollParent = getScrollParent(element);\n  const isBody = scrollParent.nodeName === 'BODY';\n  const target = isBody ? scrollParent.ownerDocument.defaultView : scrollParent;\n  const updatedList = list.concat(target);\n  return isBody\n    ? updatedList\n    : updatedList.concat(listScrollParents(getParentNode(target)));\n}\n","// @flow\nimport getParentNode from './getParentNode';\nimport getComputedStyle from './getComputedStyle';\n\nexport default function getScrollParent(node: Node): Node {\n  if (!node) {\n    return document.body;\n  }\n\n  switch (node.nodeName) {\n    case 'HTML':\n    case 'BODY':\n      return node.ownerDocument.body;\n    case '#document':\n      // Flow doesn't understand nodeName type refinement unfortunately\n      return ((node: any): Document).body;\n  }\n\n  if (node instanceof HTMLElement) {\n    // Firefox want us to check `-x` and `-y` variations as well\n    const { overflow, overflowX, overflowY } = getComputedStyle(node);\n    if (/(auto|scroll|overlay)/.test(overflow + overflowY + overflowX)) {\n      return node;\n    }\n  }\n\n  return getScrollParent(getParentNode(node));\n}\n","// @flow\nimport getWindowScroll from './getWindowScroll';\nimport getWindow from './getWindow';\nimport getHTMLElementScroll from './getHTMLElementScroll';\n\nexport default function getElementScroll(node: Node) {\n  if (node === getWindow(node) || !(node instanceof HTMLElement)) {\n    return getWindowScroll(node);\n  } else {\n    return getHTMLElementScroll(node);\n  }\n}\n","// @flow\n\nexport default function getHTMLElementScroll(element: HTMLElement) {\n  return {\n    scrollLeft: element.scrollLeft,\n    scrollTop: element.scrollTop,\n  };\n}\n","// @flow\nimport getWindow from './getWindow';\n\nexport default function getWindowScroll(node: Node) {\n  const win = getWindow(node);\n  const scrollLeft = win.pageXOffset;\n  const scrollTop = win.pageYOffset;\n  return { scrollLeft, scrollTop };\n}\n","// @flow\nimport getWindow from './getWindow';\n\nexport default function getOffsetParent(element: Element) {\n  const offsetParent =\n    element instanceof HTMLElement ? element.offsetParent : null;\n  const window = getWindow(element);\n\n  if (\n    offsetParent &&\n    offsetParent.nodeName &&\n    offsetParent.nodeName.toUpperCase() === 'BODY'\n  ) {\n    return window;\n  }\n\n  return offsetParent || window;\n}\n","// @flow\nimport getNodeScroll from './getNodeScroll';\nimport getOffsetParent from './getOffsetParent';\n\nconst sumScroll = scrollParents =>\n  scrollParents.reduce(\n    (scroll, scrollParent) => {\n      const nodeScroll = getNodeScroll(scrollParent);\n      scroll.scrollTop += nodeScroll.scrollTop;\n      scroll.scrollLeft += nodeScroll.scrollLeft;\n      return scroll;\n    },\n    { scrollTop: 0, scrollLeft: 0 }\n  );\n\nexport default function getCommonTotalScroll(\n  reference: HTMLElement,\n  referenceScrollParents: Array<Node>,\n  popperScrollParents: Array<Node>\n) {\n  // if the scrollParent is shared between the two elements, we don't pick\n  // it because it wouldn't add anything to the equation (they nulllify themselves)\n  const nonCommonReference = referenceScrollParents.filter(\n    node => !popperScrollParents.includes(node)\n  );\n\n  // we then want to pick any scroll offset except for the one of the offsetParent\n  // not sure why but that's how I got it working ðŸ˜…\n  // TODO: improve this comment with proper explanation\n  const offsetParent = getOffsetParent(reference);\n  const index = referenceScrollParents.findIndex(node => node === offsetParent);\n\n  const scrollParents = referenceScrollParents.slice(\n    0,\n    index === -1 ? undefined : index\n  );\n\n  return sumScroll(scrollParents);\n}\n","// @flow\nexport default (element: any): HTMLElement =>\n  element && element.jquery ? element[0] : element;\n","// @flow\nimport type { Modifier } from '../types';\n\n// source: https://stackoverflow.com/questions/49875255\nconst order = modifiers => {\n  // indexed by name\n  const mapped = modifiers.reduce((mem, i) => {\n    mem[i.name] = i;\n    return mem;\n  }, {});\n\n  // inherit all dependencies for a given name\n  const inherited = i => {\n    return mapped[i].requires.reduce((mem, i) => {\n      return [...mem, i, ...inherited(i)];\n    }, []);\n  };\n\n  // order ...\n  const ordered = modifiers.sort((a, b) => {\n    return !!~inherited(b.name).indexOf(a.name) ? -1 : 1;\n  });\n  return ordered;\n};\n\nexport default (modifiers: Array<Modifier>): Array<Modifier> => [\n  ...order(modifiers.filter(({ phase }) => phase === 'read')),\n  ...order(modifiers.filter(({ phase }) => phase === 'main')),\n  ...order(modifiers.filter(({ phase }) => phase === 'write')),\n];\n","// @flow\nimport type { EventListeners } from '../types';\n\n// Expands the eventListeners value to an object containing the\n// `scroll` and `resize` booleans\n//\n// true => true, true\n// false => false, false\n// true, false => true, false\n// false, false => false, false\nexport default (\n  eventListeners: boolean | { scroll?: boolean, resize?: boolean }\n): EventListeners => {\n  const fallbackValue =\n    typeof eventListeners === 'boolean' ? eventListeners : false;\n\n  return {\n    scroll:\n      typeof eventListeners.scroll === 'boolean'\n        ? eventListeners.scroll\n        : fallbackValue,\n    resize:\n      typeof eventListeners.resize === 'boolean'\n        ? eventListeners.resize\n        : fallbackValue,\n  };\n};\n","// @flow\nexport const top: 'top' = 'top';\nexport const bottom: 'bottom' = 'bottom';\nexport const right: 'right' = 'right';\nexport const left: 'left' = 'left';\nexport const auto: 'auto' = 'auto';\nexport type BasePlacement =\n  | typeof top\n  | typeof bottom\n  | typeof right\n  | typeof left\n  | typeof auto;\nexport const basePlacements: Array<BasePlacement> = [top, bottom, right, left];\n\nexport const start: 'start' = 'start';\nexport const end: 'end' = 'end';\nexport type VariationPlacement = typeof start | typeof end;\n\nexport type Placement =\n  | 'auto'\n  | 'auto-start'\n  | 'auto-end'\n  | 'top'\n  | 'top-start'\n  | 'top-end'\n  | 'bottom'\n  | 'bottom-start'\n  | 'bottom-end'\n  | 'right'\n  | 'right-start'\n  | 'right-end'\n  | 'left'\n  | 'left-start'\n  | 'left-end';\n\nexport const placements: Array<Placement> = basePlacements.reduce(\n  (acc: Array<Placement>, placement: BasePlacement): Array<Placement> =>\n    acc.concat([\n      placement,\n      (`${placement}-${start}`: any),\n      (`${placement}-${end}`: any),\n    ]),\n  []\n);\n\n// modifiers that need to read the DOM\nexport const read: 'read' = 'read';\n// pure-logic modifiers\nexport const main: 'main' = 'main';\n// modifier with the purpose to write to the DOM (or write into a framework state)\nexport const write: 'write' = 'write';\n\nexport type ModifierPhases = typeof read | typeof main | typeof write;\n","// @flow\nimport getBasePlacement from './getBasePlacement';\nimport getAltAxis from './getAltAxis';\nimport getAltLen from './getAltLen';\nimport type { Rect, PositioningStrategy, Offsets } from '../types';\nimport { top, right, bottom, left, type Placement } from '../enums';\n\nexport default ({\n  reference,\n  popper,\n  strategy,\n  placement,\n  scroll,\n}: {\n  reference: Rect,\n  popper: Rect,\n  strategy: PositioningStrategy,\n  placement: Placement,\n  scroll: { scrollTop: number, scrollLeft: number },\n}): Offsets => {\n  const basePlacement = getBasePlacement(placement);\n\n  const { scrollTop, scrollLeft } = scroll;\n\n  switch (basePlacement) {\n    case top:\n      return {\n        x: reference.x + reference.width / 2 - popper.width / 2 - scrollLeft,\n        y: reference.y - popper.height - scrollTop,\n      };\n    case bottom:\n      return {\n        x: reference.x + reference.width / 2 - popper.width / 2 - scrollLeft,\n        y: reference.y + reference.height - scrollTop,\n      };\n    case right:\n      return {\n        x: reference.x + reference.width - scrollLeft,\n        y: reference.y + reference.height / 2 - popper.height / 2 - scrollTop,\n      };\n    case left:\n    default:\n      return {\n        x: reference.x - popper.width - scrollLeft,\n        y: reference.y + reference.height / 2 - popper.height / 2 - scrollTop,\n      };\n  }\n};\n","// @flow\nimport { type BasePlacement, type Placement, typeof auto } from '../enums';\n\nexport default (placement: Placement | auto): BasePlacement =>\n  (placement.split('-')[0]: any);\n","// @flow\nexport default (str: string, ...args: Array<string>) =>\n  [...args].reduce((p, c) => p.replace(/%s/, c), str);\n","// @flow\nimport format from './format';\nimport { read, main, write } from '../enums';\n\nconst ERROR_MESSAGE =\n  'PopperJS: modifier \"%s\" provided an invalid %s property, expected %s but got %s';\nconst VALID_PROPERTIES = [\n  'name',\n  'enabled',\n  'phase',\n  'fn',\n  'onLoad',\n  'requires',\n  'options',\n];\n\nexport default (modifiers: Array<any>): void => {\n  modifiers.forEach(modifier => {\n    Object.keys(modifier).forEach(key => {\n      switch (key) {\n        case 'name':\n          if (typeof modifier.name !== 'string') {\n            console.error(\n              format(\n                ERROR_MESSAGE,\n                String(modifier.name),\n                '\"name\"',\n                '\"string\"',\n                `\"${String(modifier.name)}\"`\n              )\n            );\n          }\n          break;\n        case 'enabled':\n          if (typeof modifier.enabled !== 'boolean') {\n            console.error(\n              format(\n                ERROR_MESSAGE,\n                modifier.name,\n                '\"enabled\"',\n                '\"boolean\"',\n                `\"${String(modifier.enabled)}\"`\n              )\n            );\n          }\n        case 'phase':\n          if (![read, main, write].includes(modifier.phase)) {\n            console.error(\n              format(\n                ERROR_MESSAGE,\n                modifier.name,\n                '\"phase\"',\n                'either \"read\", \"main\" or \"write\"',\n                `\"${String(modifier.phase)}\"`\n              )\n            );\n          }\n          break;\n        case 'fn':\n          if (typeof modifier.fn !== 'function') {\n            console.error(\n              format(\n                ERROR_MESSAGE,\n                modifier.name,\n                '\"fn\"',\n                '\"function\"',\n                `\"${String(modifier.fn)}\"`\n              )\n            );\n          }\n          break;\n        case 'onLoad':\n          if (typeof modifier.onLoad !== 'function') {\n            console.error(\n              format(\n                ERROR_MESSAGE,\n                modifier.name,\n                '\"onLoad\"',\n                '\"function\"',\n                `\"${String(modifier.fn)}\"`\n              )\n            );\n          }\n          break;\n        case 'requires':\n          if (!Array.isArray(modifier.requires)) {\n            console.error(\n              format(\n                ERROR_MESSAGE,\n                modifier.name,\n                '\"requires\"',\n                '\"array\"',\n                `\"${String(modifier.requires)}\"`\n              )\n            );\n          }\n          break;\n        case 'object':\n          break;\n        default:\n          console.error(\n            `PopperJS: an invalid property has been provided to the \"${\n              modifier.name\n            }\" modifier, valid properties are ${VALID_PROPERTIES.map(\n              s => `\"${s}\"`\n            ).join(', ')}; but \"${key}\" was provided.`\n          );\n      }\n    });\n  });\n};\n","// @flow\nimport type { State, PositioningStrategy, Offsets } from '../types';\n\n// This modifier takes the Popper.js state and prepares some StyleSheet properties\n// that can be applied to the popper element to make it render in the expected position.\n\ntype Options = {\n  gpuAcceleration?: boolean,\n};\n\nexport const mapStrategyToPosition = (\n  strategy: PositioningStrategy\n): string => {\n  switch (strategy) {\n    case 'fixed':\n      return 'fixed';\n    case 'absolute':\n    default:\n      return 'absolute';\n  }\n};\n\nexport const computePopperStyles = ({\n  offsets,\n  strategy,\n  gpuAcceleration,\n}: {\n  offsets: Offsets,\n  strategy: PositioningStrategy,\n  gpuAcceleration: boolean,\n}) => {\n  // by default it is active, disable it only if explicitly set to false\n  if (gpuAcceleration === false) {\n    return {\n      top: `${offsets.y}px`,\n      left: `${offsets.x}px`,\n      position: mapStrategyToPosition(strategy),\n    };\n  } else {\n    return {\n      transform: `translate3d(${offsets.x}px, ${offsets.y}px, 0)`,\n      position: mapStrategyToPosition(strategy),\n    };\n  }\n};\n\nexport const computeArrowStyles = ({\n  offsets,\n  gpuAcceleration,\n}: {\n  offsets: Offsets,\n  gpuAcceleration: boolean,\n}) => {\n  if (gpuAcceleration) {\n    return {\n      top: `${offsets.y}px`,\n      left: `${offsets.x}px`,\n      position: 'absolute',\n    };\n  } else {\n    return {\n      transform: `translate3d(${offsets.x}px, ${offsets.y}px, 0)`,\n      position: 'absolute',\n    };\n  }\n};\n\nexport function computeStyles(state: State, options: ?Options) {\n  const gpuAcceleration =\n    options && options.gpuAcceleration != null ? options.gpuAcceleration : true;\n\n  state.styles = {};\n\n  // popper offsets are always available\n  state.styles.popper = computePopperStyles({\n    offsets: state.offsets.popper,\n    strategy: state.options.strategy,\n    gpuAcceleration,\n  });\n\n  // arrow offsets may not be available\n  if (state.offsets.arrow != null) {\n    state.styles.arrow = computeArrowStyles({\n      offsets: state.offsets.arrow,\n      gpuAcceleration,\n    });\n  }\n\n  return state;\n}\n\nexport default {\n  name: 'computeStyles',\n  enabled: true,\n  phase: 'main',\n  fn: computeStyles,\n};\n","// @flow\nimport type { State, PositioningStrategy } from '../types';\n\n// This modifier takes the styles prepared by the `computeStyles` modifier\n// and applies them to the HTMLElements such as popper and arrow\n\nexport function applyStyles(state: State) {\n  Object.keys(state.elements).forEach(name => {\n    const style = state.styles.hasOwnProperty(name) ? state.styles[name] : null;\n\n    // Flow doesn't support to extend this property, but it's the most\n    // effective way to apply styles to an HTMLElemen\n    // $FlowIgnore\n    Object.assign(state.elements[name].style, style);\n  });\n\n  return state;\n}\n\nexport default {\n  name: 'applyStyles',\n  enabled: true,\n  phase: 'write',\n  fn: applyStyles,\n  requires: ['computeStyles'],\n};\n","// @flow\nimport type {\n  JQueryWrapper,\n  State,\n  Options,\n  UpdateCallback,\n  EventListeners,\n  Rect,\n  Modifier,\n} from './types';\n\n// DOM Utils\nimport getElementClientRect from './dom-utils/getElementClientRect';\nimport listScrollParents from './dom-utils/listScrollParents';\nimport getWindow from './dom-utils/getWindow';\nimport getNodeScroll from './dom-utils/getNodeScroll';\nimport getOffsetParent from './dom-utils/getOffsetParent';\nimport getCommonTotalScroll from './dom-utils/getCommonTotalScroll';\n\n// Pure Utils\nimport unwrapJqueryElement from './utils/unwrapJqueryElement';\nimport orderModifiers from './utils/orderModifiers';\nimport expandEventListeners from './utils/expandEventListeners';\nimport computeOffsets from './utils/computeOffsets';\nimport format from './utils/format';\nimport debounce from './utils/debounce';\nimport validateModifiers from './utils/validateModifiers';\n\n// Default modifiers\nimport * as modifiers from './modifiers/index';\n\nconst defaultModifiers: Array<Modifier> = (Object.values(modifiers): any);\n\nconst INVALID_ELEMENT_ERROR =\n  'Invalid `%s` argument provided to Popper.js, it must be either a valid DOM element or a jQuery-wrapped DOM element, you provided `%s`';\n\nconst areValidElements = (a: mixed, b: mixed): boolean %checks =>\n  a instanceof Element && b instanceof Element;\n\nconst defaultOptions = {\n  placement: 'bottom',\n  eventListeners: { scroll: true, resize: true },\n  modifiers: [],\n  strategy: 'absolute',\n};\n\nexport default class Popper {\n  state: $Shape<State> = {\n    placement: 'bottom',\n    orderedModifiers: [],\n    options: defaultOptions,\n  };\n\n  constructor(\n    reference: Element | JQueryWrapper,\n    popper: Element | JQueryWrapper,\n    options: Options = defaultOptions\n  ) {\n    // make update() debounced, so that it only runs at most once-per-tick\n    (this: any).update = debounce(this.update.bind(this));\n\n    // Unwrap `reference` and `popper` elements in case they are\n    // wrapped by jQuery, otherwise consume them as is\n    this.state.elements = {\n      reference: unwrapJqueryElement(reference),\n      popper: unwrapJqueryElement(popper),\n    };\n    const {\n      reference: referenceElement,\n      popper: popperElement,\n    } = this.state.elements;\n\n    // Store options into state\n    this.state.options = { ...defaultOptions, ...options };\n\n    // Cache the placement in cache to make it available to the modifiers\n    // modifiers will modify this one (rather than the one in options)\n    this.state.placement = options.placement;\n\n    // Don't proceed if `reference` or `popper` are invalid elements\n    if (!areValidElements(referenceElement, popperElement)) {\n      return;\n    }\n\n    this.state.scrollParents = {\n      reference: listScrollParents(referenceElement),\n      popper: listScrollParents(popperElement),\n    };\n\n    // Order `options.modifiers` so that the dependencies are fulfilled\n    // once the modifiers are executed\n    this.state.orderedModifiers = orderModifiers([\n      ...defaultModifiers,\n      ...this.state.options.modifiers,\n    ]);\n\n    // Validate the provided modifiers so that the consumer will get warned\n    // of one of the custom modifiers is invalid for any reason\n    if (process.env.NODE_ENV !== 'production') {\n      validateModifiers(this.state.options.modifiers);\n    }\n\n    // Modifiers have the opportunity to execute some arbitrary code before\n    // the first update cycle is ran, the order of execution will be the same\n    // defined by the modifier dependencies directive.\n    // The `onLoad` function may add or alter the options of themselves\n    this.state.orderedModifiers.forEach(\n      ({ onLoad, enabled }) => enabled && onLoad && onLoad(this.state)\n    );\n\n    this.update().then(() => {\n      // After the first update completed, enable the event listeners\n      this.enableEventListeners(this.state.options.eventListeners);\n    });\n  }\n\n  // Async and optimistically optimized update\n  // it will not be executed if not necessary\n  // check Popper#constructor to see how it gets debounced\n  update() {\n    return new Promise<State>((success, reject) => {\n      this.forceUpdate();\n      success(this.state);\n    });\n  }\n\n  // Syncronous and forcefully executed update\n  // it will always be executed even if not necessary, usually NOT needed\n  // use Popper#update instead\n  forceUpdate() {\n    const {\n      reference: referenceElement,\n      popper: popperElement,\n    } = this.state.elements;\n    // Don't proceed if `reference` or `popper` are not valid elements anymore\n    if (!areValidElements(referenceElement, popperElement)) {\n      return;\n    }\n\n    // Get initial measurements\n    // these are going to be used to compute the initial popper offsets\n    // and as cache for any modifier that needs them later\n    this.state.measures = {\n      reference: getElementClientRect(referenceElement),\n      popper: getElementClientRect(popperElement),\n    };\n\n    // Get scrollTop and scrollLeft of the offsetParent\n    // this will be used in the `computeOffsets` function to properly\n    // position the popper taking in account the scroll position\n    // FIXME: right now we only look for a single offsetParent (the popper one)\n    //        but we really want to take in account the reference offsetParent as well\n    const offsetParentScroll = getNodeScroll(getOffsetParent(popperElement));\n\n    // Offsets are the actual position the popper needs to have to be\n    // properly positioned near its reference element\n    // This is the most basic placement, and will be adjusted by\n    // the modifiers in the next step\n    this.state.offsets = {\n      popper: computeOffsets({\n        reference: this.state.measures.reference,\n        popper: this.state.measures.popper,\n        strategy: 'absolute',\n        placement: this.state.options.placement,\n        scroll: getCommonTotalScroll(\n          referenceElement,\n          this.state.scrollParents.reference,\n          this.state.scrollParents.popper\n        ),\n      }),\n    };\n\n    // Modifiers have the ability to read the current Popper.js state, included\n    // the popper offsets, and modify it to address specifc cases\n    this.state = this.state.orderedModifiers.reduce(\n      (state, { fn, enabled, options }) => {\n        if (enabled && typeof fn === 'function') {\n          state = fn((this.state: State), options);\n        }\n        return state;\n      },\n      this.state\n    );\n  }\n\n  enableEventListeners(\n    eventListeners: boolean | { scroll?: boolean, resize?: boolean }\n  ) {\n    const {\n      reference: referenceElement,\n      popper: popperElement,\n    } = this.state.elements;\n    const { scroll, resize } = expandEventListeners(eventListeners);\n\n    if (scroll) {\n      const scrollParents = [\n        ...this.state.scrollParents.reference,\n        ...this.state.scrollParents.popper,\n      ];\n\n      scrollParents.forEach(scrollParent =>\n        scrollParent.addEventListener('scroll', this.update, {\n          passive: true,\n        })\n      );\n    }\n\n    if (resize) {\n      const win = getWindow(this.state.elements.popper);\n      win &&\n        win.addEventListener('resize', this.update, {\n          passive: true,\n        });\n    }\n  }\n}\n","// @flow\nexport default function microtaskDebounce(fn: Function) {\n  let called = false;\n  return () =>\n    new Promise<void>(resolve => {\n      if (called) {\n        return resolve();\n      }\n      called = true;\n      Promise.resolve().then(() => {\n        called = false;\n        resolve(fn());\n      });\n    });\n}\n"],"names":["getWindow","node","ownerDocument","defaultView","window","getComputedStyle","element","width","offsetWidth","height","offsetHeight","top","offsetTop","left","offsetLeft","styles","marginTop","parseFloat","marginRight","marginBottom","marginLeft","y","x","nodeName","parentNode","host","document","documentElement","listScrollParents","list","scrollParent","getScrollParent","body","HTMLElement","overflow","overflowX","overflowY","test","getParentNode","isBody","target","updatedList","concat","getElementScroll","scrollLeft","scrollTop","win","pageXOffset","pageYOffset","getWindowScroll","getOffsetParent","offsetParent","toUpperCase","sumScroll","scrollParents","reduce","scroll","nodeScroll","getNodeScroll","jquery","order","modifiers","mapped","mem","i","name","inherited","requires","sort","a","b","indexOf","filter","phase","eventListeners","fallbackValue","resize","acc","placement","read","main","write","reference","popper","strategy","basePlacement","split","getBasePlacement","str","args","p","c","replace","ERROR_MESSAGE","VALID_PROPERTIES","forEach","modifier","Object","keys","key","console","error","format","String","enabled","includes","fn","onLoad","Array","isArray","map","s","join","mapStrategyToPosition","computePopperStyles","offsets","gpuAcceleration","position","transform","computeArrowStyles","state","options","arrow","elements","style","hasOwnProperty","assign","defaultModifiers","values","areValidElements","Element","defaultOptions","constructor","orderedModifiers","update","called","Promise","resolve","then","debounce","this","bind","unwrapJqueryElement","referenceElement","popperElement","orderModifiers","validateModifiers","enableEventListeners","success","reject","forceUpdate","measures","getElementClientRect","computeOffsets","referenceScrollParents","popperScrollParents","index","findIndex","slice","undefined","getCommonTotalScroll","expandEventListeners","addEventListener","passive"],"mappings":"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"}