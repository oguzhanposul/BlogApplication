{"version":3,"file":"index.min.js","sources":["../../src/dom-utils/getWindow.js","../../src/dom-utils/getComputedStyle.js","../../src/dom-utils/getElementClientRect.js","../../src/dom-utils/getParentNode.js","../../src/dom-utils/getScrollParent.js","../../src/dom-utils/listScrollParents.js","../../src/dom-utils/getWindowScroll.js","../../src/dom-utils/getHTMLElementScroll.js","../../src/dom-utils/getNodeScroll.js","../../src/dom-utils/getOffsetParent.js","../../src/dom-utils/getCommonTotalScroll.js","../../src/utils/unwrapJqueryElement.js","../../src/utils/orderModifiers.js","../../src/utils/expandEventListeners.js","../../src/utils/getBasePlacement.js","../../src/enums.js","../../src/utils/computeOffsets.js","../../src/utils/format.js","../../src/utils/debounce.js","../../src/utils/validateModifiers.js","../../src/modifiers/computeStyles.js","../../src/modifiers/applyStyles.js","../../src/index.js"],"sourcesContent":["// @flow\nexport default function getWindow(node: Node) {\n  const ownerDocument = node.ownerDocument;\n  return ownerDocument ? ownerDocument.defaultView : window;\n}\n","// @flow\nimport getWindow from './getWindow';\n\nexport default function getComputedStyle(element: HTMLElement) {\n  return getWindow(element).getComputedStyle(element);\n}\n","// @flow\nimport getComputedStyle from './getComputedStyle';\n\n// Returns the width, height and offsets of the provided element\nexport default (element: HTMLElement) => {\n  // get the basic client rect, it doesn't include margins\n  const width = element.offsetWidth;\n  const height = element.offsetHeight;\n  const top = element.offsetTop;\n  const left = element.offsetLeft;\n\n  // get the element margins, we need them to properly align the popper\n  const styles = getComputedStyle(element);\n\n  const marginTop = parseFloat(styles.marginTop) || 0;\n  const marginRight = parseFloat(styles.marginRight) || 0;\n  const marginBottom = parseFloat(styles.marginBottom) || 0;\n  const marginLeft = parseFloat(styles.marginLeft) || 0;\n\n  return {\n    width: width + marginLeft + marginRight,\n    height: height + marginTop + marginBottom,\n    y: top - marginTop,\n    x: left - marginLeft,\n  };\n};\n","// @flow\nexport default (element: Node | ShadowRoot): Node => {\n  if (element.nodeName === 'HTML') {\n    // DocumentElement detectedF\n    return element;\n  }\n  return (\n    element.parentNode || // DOM Element detected\n    // $FlowFixMe: need a better way to handle this...\n    element.host || // ShadowRoot detected\n    document.ownerDocument || // Fallback to ownerDocument if available\n    document.documentElement // Or to documentElement if everything else fails\n  );\n};\n","// @flow\nimport getParentNode from './getParentNode';\nimport getComputedStyle from './getComputedStyle';\n\nexport default function getScrollParent(node: Node): Node {\n  if (!node) {\n    return document.body;\n  }\n\n  switch (node.nodeName) {\n    case 'HTML':\n    case 'BODY':\n      return node.ownerDocument.body;\n    case '#document':\n      // Flow doesn't understand nodeName type refinement unfortunately\n      return ((node: any): Document).body;\n  }\n\n  if (node instanceof HTMLElement) {\n    // Firefox want us to check `-x` and `-y` variations as well\n    const { overflow, overflowX, overflowY } = getComputedStyle(node);\n    if (/(auto|scroll|overlay)/.test(overflow + overflowY + overflowX)) {\n      return node;\n    }\n  }\n\n  return getScrollParent(getParentNode(node));\n}\n","// @flow\nimport getScrollParent from './getScrollParent';\nimport getParentNode from './getParentNode';\n\nexport default function listScrollParents(\n  element: Node,\n  list: Array<Node> = []\n): Array<Node> {\n  const scrollParent = getScrollParent(element);\n  const isBody = scrollParent.nodeName === 'BODY';\n  const target = isBody ? scrollParent.ownerDocument.defaultView : scrollParent;\n  const updatedList = list.concat(target);\n  return isBody\n    ? updatedList\n    : updatedList.concat(listScrollParents(getParentNode(target)));\n}\n","// @flow\nimport getWindow from './getWindow';\n\nexport default function getWindowScroll(node: Node) {\n  const win = getWindow(node);\n  const scrollLeft = win.pageXOffset;\n  const scrollTop = win.pageYOffset;\n  return { scrollLeft, scrollTop };\n}\n","// @flow\n\nexport default function getHTMLElementScroll(element: HTMLElement) {\n  return {\n    scrollLeft: element.scrollLeft,\n    scrollTop: element.scrollTop,\n  };\n}\n","// @flow\nimport getWindowScroll from './getWindowScroll';\nimport getWindow from './getWindow';\nimport getHTMLElementScroll from './getHTMLElementScroll';\n\nexport default function getElementScroll(node: Node) {\n  if (node === getWindow(node) || !(node instanceof HTMLElement)) {\n    return getWindowScroll(node);\n  } else {\n    return getHTMLElementScroll(node);\n  }\n}\n","// @flow\nimport getWindow from './getWindow';\n\nexport default function getOffsetParent(element: Element) {\n  const offsetParent =\n    element instanceof HTMLElement ? element.offsetParent : null;\n  const window = getWindow(element);\n\n  if (\n    offsetParent &&\n    offsetParent.nodeName &&\n    offsetParent.nodeName.toUpperCase() === 'BODY'\n  ) {\n    return window;\n  }\n\n  return offsetParent || window;\n}\n","// @flow\nimport getNodeScroll from './getNodeScroll';\nimport getOffsetParent from './getOffsetParent';\n\nconst sumScroll = scrollParents =>\n  scrollParents.reduce(\n    (scroll, scrollParent) => {\n      const nodeScroll = getNodeScroll(scrollParent);\n      scroll.scrollTop += nodeScroll.scrollTop;\n      scroll.scrollLeft += nodeScroll.scrollLeft;\n      return scroll;\n    },\n    { scrollTop: 0, scrollLeft: 0 }\n  );\n\nexport default function getCommonTotalScroll(\n  reference: HTMLElement,\n  referenceScrollParents: Array<Node>,\n  popperScrollParents: Array<Node>\n) {\n  // if the scrollParent is shared between the two elements, we don't pick\n  // it because it wouldn't add anything to the equation (they nulllify themselves)\n  const nonCommonReference = referenceScrollParents.filter(\n    node => !popperScrollParents.includes(node)\n  );\n\n  // we then want to pick any scroll offset except for the one of the offsetParent\n  // not sure why but that's how I got it working ðŸ˜…\n  // TODO: improve this comment with proper explanation\n  const offsetParent = getOffsetParent(reference);\n  const index = referenceScrollParents.findIndex(node => node === offsetParent);\n\n  const scrollParents = referenceScrollParents.slice(\n    0,\n    index === -1 ? undefined : index\n  );\n\n  return sumScroll(scrollParents);\n}\n","// @flow\nexport default (element: any): HTMLElement =>\n  element && element.jquery ? element[0] : element;\n","// @flow\nimport type { Modifier } from '../types';\n\n// source: https://stackoverflow.com/questions/49875255\nconst order = modifiers => {\n  // indexed by name\n  const mapped = modifiers.reduce((mem, i) => {\n    mem[i.name] = i;\n    return mem;\n  }, {});\n\n  // inherit all dependencies for a given name\n  const inherited = i => {\n    return mapped[i].requires.reduce((mem, i) => {\n      return [...mem, i, ...inherited(i)];\n    }, []);\n  };\n\n  // order ...\n  const ordered = modifiers.sort((a, b) => {\n    return !!~inherited(b.name).indexOf(a.name) ? -1 : 1;\n  });\n  return ordered;\n};\n\nexport default (modifiers: Array<Modifier>): Array<Modifier> => [\n  ...order(modifiers.filter(({ phase }) => phase === 'read')),\n  ...order(modifiers.filter(({ phase }) => phase === 'main')),\n  ...order(modifiers.filter(({ phase }) => phase === 'write')),\n];\n","// @flow\nimport type { EventListeners } from '../types';\n\n// Expands the eventListeners value to an object containing the\n// `scroll` and `resize` booleans\n//\n// true => true, true\n// false => false, false\n// true, false => true, false\n// false, false => false, false\nexport default (\n  eventListeners: boolean | { scroll?: boolean, resize?: boolean }\n): EventListeners => {\n  const fallbackValue =\n    typeof eventListeners === 'boolean' ? eventListeners : false;\n\n  return {\n    scroll:\n      typeof eventListeners.scroll === 'boolean'\n        ? eventListeners.scroll\n        : fallbackValue,\n    resize:\n      typeof eventListeners.resize === 'boolean'\n        ? eventListeners.resize\n        : fallbackValue,\n  };\n};\n","// @flow\nimport { type BasePlacement, type Placement, typeof auto } from '../enums';\n\nexport default (placement: Placement | auto): BasePlacement =>\n  (placement.split('-')[0]: any);\n","// @flow\nexport const top: 'top' = 'top';\nexport const bottom: 'bottom' = 'bottom';\nexport const right: 'right' = 'right';\nexport const left: 'left' = 'left';\nexport const auto: 'auto' = 'auto';\nexport type BasePlacement =\n  | typeof top\n  | typeof bottom\n  | typeof right\n  | typeof left\n  | typeof auto;\nexport const basePlacements: Array<BasePlacement> = [top, bottom, right, left];\n\nexport const start: 'start' = 'start';\nexport const end: 'end' = 'end';\nexport type VariationPlacement = typeof start | typeof end;\n\nexport type Placement =\n  | 'auto'\n  | 'auto-start'\n  | 'auto-end'\n  | 'top'\n  | 'top-start'\n  | 'top-end'\n  | 'bottom'\n  | 'bottom-start'\n  | 'bottom-end'\n  | 'right'\n  | 'right-start'\n  | 'right-end'\n  | 'left'\n  | 'left-start'\n  | 'left-end';\n\nexport const placements: Array<Placement> = basePlacements.reduce(\n  (acc: Array<Placement>, placement: BasePlacement): Array<Placement> =>\n    acc.concat([\n      placement,\n      (`${placement}-${start}`: any),\n      (`${placement}-${end}`: any),\n    ]),\n  []\n);\n\n// modifiers that need to read the DOM\nexport const read: 'read' = 'read';\n// pure-logic modifiers\nexport const main: 'main' = 'main';\n// modifier with the purpose to write to the DOM (or write into a framework state)\nexport const write: 'write' = 'write';\n\nexport type ModifierPhases = typeof read | typeof main | typeof write;\n","// @flow\nimport getBasePlacement from './getBasePlacement';\nimport getAltAxis from './getAltAxis';\nimport getAltLen from './getAltLen';\nimport type { Rect, PositioningStrategy, Offsets } from '../types';\nimport { top, right, bottom, left, type Placement } from '../enums';\n\nexport default ({\n  reference,\n  popper,\n  strategy,\n  placement,\n  scroll,\n}: {\n  reference: Rect,\n  popper: Rect,\n  strategy: PositioningStrategy,\n  placement: Placement,\n  scroll: { scrollTop: number, scrollLeft: number },\n}): Offsets => {\n  const basePlacement = getBasePlacement(placement);\n\n  const { scrollTop, scrollLeft } = scroll;\n\n  switch (basePlacement) {\n    case top:\n      return {\n        x: reference.x + reference.width / 2 - popper.width / 2 - scrollLeft,\n        y: reference.y - popper.height - scrollTop,\n      };\n    case bottom:\n      return {\n        x: reference.x + reference.width / 2 - popper.width / 2 - scrollLeft,\n        y: reference.y + reference.height - scrollTop,\n      };\n    case right:\n      return {\n        x: reference.x + reference.width - scrollLeft,\n        y: reference.y + reference.height / 2 - popper.height / 2 - scrollTop,\n      };\n    case left:\n    default:\n      return {\n        x: reference.x - popper.width - scrollLeft,\n        y: reference.y + reference.height / 2 - popper.height / 2 - scrollTop,\n      };\n  }\n};\n","// @flow\nexport default (str: string, ...args: Array<string>) =>\n  [...args].reduce((p, c) => p.replace(/%s/, c), str);\n","// @flow\nexport default function microtaskDebounce(fn: Function) {\n  let called = false;\n  return () =>\n    new Promise<void>(resolve => {\n      if (called) {\n        return resolve();\n      }\n      called = true;\n      Promise.resolve().then(() => {\n        called = false;\n        resolve(fn());\n      });\n    });\n}\n","// @flow\nimport format from './format';\nimport { read, main, write } from '../enums';\n\nconst ERROR_MESSAGE =\n  'PopperJS: modifier \"%s\" provided an invalid %s property, expected %s but got %s';\nconst VALID_PROPERTIES = [\n  'name',\n  'enabled',\n  'phase',\n  'fn',\n  'onLoad',\n  'requires',\n  'options',\n];\n\nexport default (modifiers: Array<any>): void => {\n  modifiers.forEach(modifier => {\n    Object.keys(modifier).forEach(key => {\n      switch (key) {\n        case 'name':\n          if (typeof modifier.name !== 'string') {\n            console.error(\n              format(\n                ERROR_MESSAGE,\n                String(modifier.name),\n                '\"name\"',\n                '\"string\"',\n                `\"${String(modifier.name)}\"`\n              )\n            );\n          }\n          break;\n        case 'enabled':\n          if (typeof modifier.enabled !== 'boolean') {\n            console.error(\n              format(\n                ERROR_MESSAGE,\n                modifier.name,\n                '\"enabled\"',\n                '\"boolean\"',\n                `\"${String(modifier.enabled)}\"`\n              )\n            );\n          }\n        case 'phase':\n          if (![read, main, write].includes(modifier.phase)) {\n            console.error(\n              format(\n                ERROR_MESSAGE,\n                modifier.name,\n                '\"phase\"',\n                'either \"read\", \"main\" or \"write\"',\n                `\"${String(modifier.phase)}\"`\n              )\n            );\n          }\n          break;\n        case 'fn':\n          if (typeof modifier.fn !== 'function') {\n            console.error(\n              format(\n                ERROR_MESSAGE,\n                modifier.name,\n                '\"fn\"',\n                '\"function\"',\n                `\"${String(modifier.fn)}\"`\n              )\n            );\n          }\n          break;\n        case 'onLoad':\n          if (typeof modifier.onLoad !== 'function') {\n            console.error(\n              format(\n                ERROR_MESSAGE,\n                modifier.name,\n                '\"onLoad\"',\n                '\"function\"',\n                `\"${String(modifier.fn)}\"`\n              )\n            );\n          }\n          break;\n        case 'requires':\n          if (!Array.isArray(modifier.requires)) {\n            console.error(\n              format(\n                ERROR_MESSAGE,\n                modifier.name,\n                '\"requires\"',\n                '\"array\"',\n                `\"${String(modifier.requires)}\"`\n              )\n            );\n          }\n          break;\n        case 'object':\n          break;\n        default:\n          console.error(\n            `PopperJS: an invalid property has been provided to the \"${\n              modifier.name\n            }\" modifier, valid properties are ${VALID_PROPERTIES.map(\n              s => `\"${s}\"`\n            ).join(', ')}; but \"${key}\" was provided.`\n          );\n      }\n    });\n  });\n};\n","// @flow\nimport type { State, PositioningStrategy, Offsets } from '../types';\n\n// This modifier takes the Popper.js state and prepares some StyleSheet properties\n// that can be applied to the popper element to make it render in the expected position.\n\ntype Options = {\n  gpuAcceleration?: boolean,\n};\n\nexport const mapStrategyToPosition = (\n  strategy: PositioningStrategy\n): string => {\n  switch (strategy) {\n    case 'fixed':\n      return 'fixed';\n    case 'absolute':\n    default:\n      return 'absolute';\n  }\n};\n\nexport const computePopperStyles = ({\n  offsets,\n  strategy,\n  gpuAcceleration,\n}: {\n  offsets: Offsets,\n  strategy: PositioningStrategy,\n  gpuAcceleration: boolean,\n}) => {\n  // by default it is active, disable it only if explicitly set to false\n  if (gpuAcceleration === false) {\n    return {\n      top: `${offsets.y}px`,\n      left: `${offsets.x}px`,\n      position: mapStrategyToPosition(strategy),\n    };\n  } else {\n    return {\n      transform: `translate3d(${offsets.x}px, ${offsets.y}px, 0)`,\n      position: mapStrategyToPosition(strategy),\n    };\n  }\n};\n\nexport const computeArrowStyles = ({\n  offsets,\n  gpuAcceleration,\n}: {\n  offsets: Offsets,\n  gpuAcceleration: boolean,\n}) => {\n  if (gpuAcceleration) {\n    return {\n      top: `${offsets.y}px`,\n      left: `${offsets.x}px`,\n      position: 'absolute',\n    };\n  } else {\n    return {\n      transform: `translate3d(${offsets.x}px, ${offsets.y}px, 0)`,\n      position: 'absolute',\n    };\n  }\n};\n\nexport function computeStyles(state: State, options: ?Options) {\n  const gpuAcceleration =\n    options && options.gpuAcceleration != null ? options.gpuAcceleration : true;\n\n  state.styles = {};\n\n  // popper offsets are always available\n  state.styles.popper = computePopperStyles({\n    offsets: state.offsets.popper,\n    strategy: state.options.strategy,\n    gpuAcceleration,\n  });\n\n  // arrow offsets may not be available\n  if (state.offsets.arrow != null) {\n    state.styles.arrow = computeArrowStyles({\n      offsets: state.offsets.arrow,\n      gpuAcceleration,\n    });\n  }\n\n  return state;\n}\n\nexport default {\n  name: 'computeStyles',\n  enabled: true,\n  phase: 'main',\n  fn: computeStyles,\n};\n","// @flow\nimport type { State, PositioningStrategy } from '../types';\n\n// This modifier takes the styles prepared by the `computeStyles` modifier\n// and applies them to the HTMLElements such as popper and arrow\n\nexport function applyStyles(state: State) {\n  Object.keys(state.elements).forEach(name => {\n    const style = state.styles.hasOwnProperty(name) ? state.styles[name] : null;\n\n    // Flow doesn't support to extend this property, but it's the most\n    // effective way to apply styles to an HTMLElemen\n    // $FlowIgnore\n    Object.assign(state.elements[name].style, style);\n  });\n\n  return state;\n}\n\nexport default {\n  name: 'applyStyles',\n  enabled: true,\n  phase: 'write',\n  fn: applyStyles,\n  requires: ['computeStyles'],\n};\n","// @flow\nimport type {\n  JQueryWrapper,\n  State,\n  Options,\n  UpdateCallback,\n  EventListeners,\n  Rect,\n  Modifier,\n} from './types';\n\n// DOM Utils\nimport getElementClientRect from './dom-utils/getElementClientRect';\nimport listScrollParents from './dom-utils/listScrollParents';\nimport getWindow from './dom-utils/getWindow';\nimport getNodeScroll from './dom-utils/getNodeScroll';\nimport getOffsetParent from './dom-utils/getOffsetParent';\nimport getCommonTotalScroll from './dom-utils/getCommonTotalScroll';\n\n// Pure Utils\nimport unwrapJqueryElement from './utils/unwrapJqueryElement';\nimport orderModifiers from './utils/orderModifiers';\nimport expandEventListeners from './utils/expandEventListeners';\nimport computeOffsets from './utils/computeOffsets';\nimport format from './utils/format';\nimport debounce from './utils/debounce';\nimport validateModifiers from './utils/validateModifiers';\n\n// Default modifiers\nimport * as modifiers from './modifiers/index';\n\nconst defaultModifiers: Array<Modifier> = (Object.values(modifiers): any);\n\nconst INVALID_ELEMENT_ERROR =\n  'Invalid `%s` argument provided to Popper.js, it must be either a valid DOM element or a jQuery-wrapped DOM element, you provided `%s`';\n\nconst areValidElements = (a: mixed, b: mixed): boolean %checks =>\n  a instanceof Element && b instanceof Element;\n\nconst defaultOptions = {\n  placement: 'bottom',\n  eventListeners: { scroll: true, resize: true },\n  modifiers: [],\n  strategy: 'absolute',\n};\n\nexport default class Popper {\n  state: $Shape<State> = {\n    placement: 'bottom',\n    orderedModifiers: [],\n    options: defaultOptions,\n  };\n\n  constructor(\n    reference: Element | JQueryWrapper,\n    popper: Element | JQueryWrapper,\n    options: Options = defaultOptions\n  ) {\n    // make update() debounced, so that it only runs at most once-per-tick\n    (this: any).update = debounce(this.update.bind(this));\n\n    // Unwrap `reference` and `popper` elements in case they are\n    // wrapped by jQuery, otherwise consume them as is\n    this.state.elements = {\n      reference: unwrapJqueryElement(reference),\n      popper: unwrapJqueryElement(popper),\n    };\n    const {\n      reference: referenceElement,\n      popper: popperElement,\n    } = this.state.elements;\n\n    // Store options into state\n    this.state.options = { ...defaultOptions, ...options };\n\n    // Cache the placement in cache to make it available to the modifiers\n    // modifiers will modify this one (rather than the one in options)\n    this.state.placement = options.placement;\n\n    // Don't proceed if `reference` or `popper` are invalid elements\n    if (!areValidElements(referenceElement, popperElement)) {\n      return;\n    }\n\n    this.state.scrollParents = {\n      reference: listScrollParents(referenceElement),\n      popper: listScrollParents(popperElement),\n    };\n\n    // Order `options.modifiers` so that the dependencies are fulfilled\n    // once the modifiers are executed\n    this.state.orderedModifiers = orderModifiers([\n      ...defaultModifiers,\n      ...this.state.options.modifiers,\n    ]);\n\n    // Validate the provided modifiers so that the consumer will get warned\n    // of one of the custom modifiers is invalid for any reason\n    if (process.env.NODE_ENV !== 'production') {\n      validateModifiers(this.state.options.modifiers);\n    }\n\n    // Modifiers have the opportunity to execute some arbitrary code before\n    // the first update cycle is ran, the order of execution will be the same\n    // defined by the modifier dependencies directive.\n    // The `onLoad` function may add or alter the options of themselves\n    this.state.orderedModifiers.forEach(\n      ({ onLoad, enabled }) => enabled && onLoad && onLoad(this.state)\n    );\n\n    this.update().then(() => {\n      // After the first update completed, enable the event listeners\n      this.enableEventListeners(this.state.options.eventListeners);\n    });\n  }\n\n  // Async and optimistically optimized update\n  // it will not be executed if not necessary\n  // check Popper#constructor to see how it gets debounced\n  update() {\n    return new Promise<State>((success, reject) => {\n      this.forceUpdate();\n      success(this.state);\n    });\n  }\n\n  // Syncronous and forcefully executed update\n  // it will always be executed even if not necessary, usually NOT needed\n  // use Popper#update instead\n  forceUpdate() {\n    const {\n      reference: referenceElement,\n      popper: popperElement,\n    } = this.state.elements;\n    // Don't proceed if `reference` or `popper` are not valid elements anymore\n    if (!areValidElements(referenceElement, popperElement)) {\n      return;\n    }\n\n    // Get initial measurements\n    // these are going to be used to compute the initial popper offsets\n    // and as cache for any modifier that needs them later\n    this.state.measures = {\n      reference: getElementClientRect(referenceElement),\n      popper: getElementClientRect(popperElement),\n    };\n\n    // Get scrollTop and scrollLeft of the offsetParent\n    // this will be used in the `computeOffsets` function to properly\n    // position the popper taking in account the scroll position\n    // FIXME: right now we only look for a single offsetParent (the popper one)\n    //        but we really want to take in account the reference offsetParent as well\n    const offsetParentScroll = getNodeScroll(getOffsetParent(popperElement));\n\n    // Offsets are the actual position the popper needs to have to be\n    // properly positioned near its reference element\n    // This is the most basic placement, and will be adjusted by\n    // the modifiers in the next step\n    this.state.offsets = {\n      popper: computeOffsets({\n        reference: this.state.measures.reference,\n        popper: this.state.measures.popper,\n        strategy: 'absolute',\n        placement: this.state.options.placement,\n        scroll: getCommonTotalScroll(\n          referenceElement,\n          this.state.scrollParents.reference,\n          this.state.scrollParents.popper\n        ),\n      }),\n    };\n\n    // Modifiers have the ability to read the current Popper.js state, included\n    // the popper offsets, and modify it to address specifc cases\n    this.state = this.state.orderedModifiers.reduce(\n      (state, { fn, enabled, options }) => {\n        if (enabled && typeof fn === 'function') {\n          state = fn((this.state: State), options);\n        }\n        return state;\n      },\n      this.state\n    );\n  }\n\n  enableEventListeners(\n    eventListeners: boolean | { scroll?: boolean, resize?: boolean }\n  ) {\n    const {\n      reference: referenceElement,\n      popper: popperElement,\n    } = this.state.elements;\n    const { scroll, resize } = expandEventListeners(eventListeners);\n\n    if (scroll) {\n      const scrollParents = [\n        ...this.state.scrollParents.reference,\n        ...this.state.scrollParents.popper,\n      ];\n\n      scrollParents.forEach(scrollParent =>\n        scrollParent.addEventListener('scroll', this.update, {\n          passive: true,\n        })\n      );\n    }\n\n    if (resize) {\n      const win = getWindow(this.state.elements.popper);\n      win &&\n        win.addEventListener('resize', this.update, {\n          passive: true,\n        });\n    }\n  }\n}\n"],"names":["getWindow","node","ownerDocument","defaultView","window","getComputedStyle","element","width","offsetWidth","height","offsetHeight","top","offsetTop","left","offsetLeft","styles","marginTop","parseFloat","marginRight","marginBottom","marginLeft","y","x","nodeName","parentNode","host","document","documentElement","getScrollParent","body","HTMLElement","overflow","overflowX","overflowY","test","getParentNode","listScrollParents","list","scrollParent","isBody","target","updatedList","concat","getWindowScroll","win","scrollLeft","pageXOffset","scrollTop","pageYOffset","getHTMLElementScroll","getElementScroll","getOffsetParent","offsetParent","toUpperCase","sumScroll","scrollParents","reduce","scroll","nodeScroll","getNodeScroll","getCommonTotalScroll","reference","referenceScrollParents","popperScrollParents","filter","includes","index","findIndex","slice","undefined","jquery","order","modifiers","mapped","mem","i","name","inherited","requires","sort","a","b","indexOf","phase","eventListeners","fallbackValue","resize","placement","split","bottom","right","basePlacements","start","end","placements","acc","read","main","write","popper","strategy","basePlacement","getBasePlacement","str","args","p","c","replace","microtaskDebounce","fn","called","Promise","resolve","then","ERROR_MESSAGE","VALID_PROPERTIES","forEach","modifier","Object","keys","key","console","error","format","String","enabled","onLoad","Array","isArray","map","s","join","mapStrategyToPosition","computePopperStyles","offsets","gpuAcceleration","position","transform","computeArrowStyles","computeStyles","state","options","arrow","applyStyles","elements","style","hasOwnProperty","assign","defaultModifiers","values","areValidElements","Element","defaultOptions","Popper","constructor","orderedModifiers","update","debounce","this","bind","unwrapJqueryElement","referenceElement","popperElement","orderModifiers","validateModifiers","enableEventListeners","success","reject","forceUpdate","measures","getElementClientRect","computeOffsets","expandEventListeners","addEventListener","passive"],"mappings":"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"}